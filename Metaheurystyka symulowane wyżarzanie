import numpy as np
import random
import copy

N = 9  # rozmiar planszy, np. 9x9
T = 9  # liczba czarnych tur

# Przyklad początkowej planszy
# 0 = puste, 1 = czarne, 2 = białe
initial_board = np.zeros((N, N), dtype=int)
initial_board[3, 3] = 2
initial_board[3, 4] = 2
initial_board[4, 3] = 1


#Funkcja sprawdzająca czy pole ma oddech
def has_liberty(board, x, y, visited=None):
    if visited is None:
        visited = set()
    if (x, y) in visited:
        return False
    visited.add((x, y))
    color = board[x, y]
    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
        nx, ny = x+dx, y+dy
        if 0 <= nx < board.shape[0] and 0 <= ny < board.shape[1]:
            if board[nx, ny] == 0:
                return True
            if board[nx, ny] == color and has_liberty(board, nx, ny, visited):
                return True
    return False


#Funkcja do usuwania martwych (otoczonych ) kamieni
def remove_dead_stones(board, color):
    board = board.copy()
    visited = set()
    for x in range(board.shape[0]):
        for y in range(board.shape[1]):
            if board[x, y] == color and (x, y) not in visited:
                group = []
                stack = [(x, y)]
                has_lib = False
                while stack:
                    i, j = stack.pop()
                    if (i, j) in visited:
                        continue
                    visited.add((i, j))
                    group.append((i, j))
                    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
                        ni, nj = i + dx, j + dy
                        if 0 <= ni < board.shape[0] and 0 <= nj < board.shape[1]:
                            if board[ni, nj] == 0:
                                has_lib = True
                            elif board[ni, nj] == color:
                                stack.append((ni, nj))
                if not has_lib:
                    for i, j in group:
                        board[i, j] = 0
    return board


def apply_moves(board, moves):
    new_board = board.copy()
    for (x, y) in moves:
        if new_board[x, y] != 0:
            return None  # nielegalny ruch
        new_board[x, y] = 1
        new_board = remove_dead_stones(new_board, 2)  # usuwamy zbite białe
        new_board = remove_dead_stones(new_board, 1)  # unikamy samobójstw
    return new_board


def count_white_captures(before, after):
    return np.sum(before == 2) - np.sum(after == 2)


def objective(board_before, moves):
    board_after = apply_moves(board_before, moves)
    if board_after is None:
        return -1e9  # kara za nielegalne ruchy
    captures = count_white_captures(board_before, board_after)
    return captures + len(moves)


def generate_neighbor(moves, board_shape, board):
    new_moves = moves.copy()
    idx = random.randint(0, len(moves) - 1)
    for _ in range(100):
        x, y = random.randint(0, board_shape[0]-1), random.randint(0, board_shape[1]-1)
        if board[x, y] == 0 and (x, y) not in new_moves:
            new_moves[idx] = (x, y)
            break
    return new_moves


def simulated_annealing(board, T, iterations=1000, temp_start=10.0, temp_end=0.1):
    empty = list(zip(*np.where(board == 0)))
    current = random.sample(empty, T)
    best = current
    best_score = objective(board, best)
    temp = temp_start

    for it in range(iterations):
        neighbor = generate_neighbor(current, board.shape, board)
        score_curr = objective(board, current)
        score_neigh = objective(board, neighbor)
        delta = score_neigh - score_curr

        if delta > 0 or random.random() < np.exp(delta / temp):
            current = neighbor
            if score_neigh > best_score:
                best_score = score_neigh
                best = neighbor

        # Aktualizacja temperatury (logarytmicznie)
        temp = temp_start * (temp_end / temp_start) ** (it / iterations)

    return best, best_score



best_moves, best_score = simulated_annealing(initial_board, T)
print("Najlepszy wynik:", best_score)
print("Ruchy:")
for move in best_moves:
    print(move)
